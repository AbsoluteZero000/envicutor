runtime
  - id: int auto increment
  - name: string
  - source_file_name: string

===================

Limits {
  wall_time: seconds,
  cpu_time: seconds,
  memory: kilobytes,
  extra_time: seconds
  max_open_files: int
  max_file_size: kilobytes
  max_number_of_processes: int
}

MAX_BOX_ID = 2 ** 23
METADATA_FILE_NAME = "metadata.txt"

- async install_package(semaphore, glob box_id, glob metadata_cache, db, req, res):
  - box_id = (box_id + 1) % MAX_BOX_ID
  - current_box_id = box_id
  - isolate --init -b{current_box_id}
  - workdir = "/tmp/{current_box_id}"
  - metadata_file_path = '{workdir}/{METADATA_FILE_NAME}'
  - rm -rf workdir
  - mkdir workdir
  - write req.nix_shell into {workdir}/shell.nix
  - semaphore acquire
  - cmd_res = exec `isolate --run
    --meta={metadata_file_path}
    --cg
    --dir=/nix/store:rw,dev
    --dir={workdir}
    --cg-mem={req.memory}
    --wall-time={req.wall_time}
    --time={req.cpu_time}
    --extra-time={req.extra_time}
    --open-files={req.max_open_files}
    --fsize={req.max_file_size}
    --processes={req.max_number_of_processes}
    -b{current_box_id}
    --
    nix-shell {workdir}/shell.nix --run export`

  - if (cmd_res exited without errors)
    - stmt = db.prepare("INSERT INTO runtime(name, source_file_name) VALUES(:name, :source_file_name)")
    - stmt.bindString("name", req.name);
    - stmt.bindString("source_file_name", req.source_file_name);
    - stmt.execute()
    - runtime_id = db.execute("SELECT last_insert_rowid()").first()[0]
    - rm -rf /envicutor/runtimes/{runtime_id}
    - mkdir /envicutor/runtimes/{runtime_id}
    - if req.compile_script is not null
      - write(/envicutor/runtimes/{runtime_id}/compile, req.compile_script)
      - chmod a+x /envicutor/runtimes/{runtime_id}/compile
    - write(/envicutor/runtimes/{runtime_id}/run, req.run_script)
    - chmod a+x /envicutor/runtimes/{runtime_id}/run
    - write(/envicutor/runtimes/{runtime_id}/env, cmd_res.output)
    - chmod a+x /envicutor/runtimes/{runtime_id}/env
    - write(/envicutor/runtimes/{runtime_id}/shell.nix, req.nix_shell)
    - metadata_cache.set(runtime_id, {name: req.name})

  - semaphore release

  - exec `isolate --cleanup --cg -b{current_box_id}`

  - memory = null
  - exit_code = null
  - exit_signal = null
  - exit_message = null
  - exit_status = null
  - stdout = cmd_res.stdout
  - stderr = cmd_res.stderr
  - cpu_time = null
  - wall_time = null
  - metadata_lines = read_lines(metadata_file_path)
  - for line in metadata_lines:
    - key, val = line.split(":")
    - if key == "cgmem":
      - exit_code = val
    - else if key == "exitcode":
      - exit_code = val
    - else if key == "exitsig":
      - exit_signal = val
    - else if key == "message":
      - exit_message = val
    - else if key == "status":
      - exit_status = val
    - else if key == "time":
      - cpu_time = val
    - else if key == "time-wall":
      - wall_time = val

  - rm -r {workdir}

  - res.status(200).send({
      memory,
      exit_code,
      exit_signal,
      exit_message,
      exit_status,
      stdout,
      stderr,
      cpu_time,
      wall_time
    });
